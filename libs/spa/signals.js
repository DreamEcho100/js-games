const f={SIGNAL:0,EFFECT:1,MEMO:2},d=Symbol("signal");let m=0,n={id:m++,depth:0,nextSignalId:0,batchDepth:0,activeObserver:null,pendingEffects:new Set,pendingMicrotask:!1,nextScopes:[],prevScope:null,nodes:new Set,cleanups:[],name:void 0,contexts:new Map};const D=n;function x(e){for(const r of e.nextScopes)x(r);e.nextScopes=[];for(const r of e.nodes)y(r);e.contexts.clear(),e.nodes.clear(),e.pendingEffects.clear(),e.pendingMicrotask=!1,e.cleanups.forEach(r=>r()),e.cleanups=[],e.prevScope&&(e.prevScope.nextScopes=e.prevScope.nextScopes.filter(r=>r.id!==e.id)),e.prevScope=null}function I(e,r){const t=n,c={id:m++,name:r?.name,depth:t.depth+1,nextSignalId:0,batchDepth:0,activeObserver:null,pendingEffects:new Set,nodes:new Set,pendingMicrotask:!1,nextScopes:[],prevScope:r?.detached?null:t,cleanups:[],contexts:new Map};r?.detached||t.nextScopes.push(c),n=c;let s;try{if(r?.deferredProviders){for(const o of r.deferredProviders){if(!s){s=o;continue}s=o(s)}s=s?s(e):e()}else s=e()}finally{n=t}return{result:s,dispose:()=>{x(c)}}}function S(e){if(n?.cleanups)n.cleanups.push(e);else throw console.warn("⚠️ Attempted to register a cleanup function outside of a scope."),new Error("No active scope for cleanup registration.")}function N(){return n.id}function h(e,r){const t={id:n.nextSignalId++,version:0,value:e,compute:void 0,cleanup:void 0,error:void 0,dirty:!1,onDirty:void 0,sources:new Map,observers:new Set,scopeRef:n,...r};return n.nodes.add(t),t}function P(e){const r=n.activeObserver;n.activeObserver=null;try{return e()}finally{n.activeObserver=r}}function E(e){n.activeObserver&&(n.activeObserver.sources.has(e)||(n.activeObserver.sources.set(e,e.version),e.observers.add(n.activeObserver)))}function w(e){for(const r of e.pendingEffects)l(r);e.pendingEffects.clear();for(const r of e.nextScopes)w(r)}function b(){n.pendingMicrotask||n.pendingEffects.size===0||(n.pendingMicrotask=!0,queueMicrotask(()=>{!n.prevScope&&n.id!==D.id||(n.pendingMicrotask=!1,w(n))}))}function M(e){const r=Array.from(e.observers);for(const t of r)t.dirty||(t.dirty=!0,t.onDirty?t.onDirty():(n.pendingEffects.add(t),n.batchDepth===0&&b()))}function y(e){e.cleanup&&(e.cleanup(),e.cleanup=void 0),u(e);for(const r of e.observers)r.sources.delete(e);e.observers.clear(),e.scopeRef.pendingEffects.delete(e),e.scopeRef.nodes.delete(e),e.compute=void 0}const O=Object.is;function p(e){return typeof e=="function"&&d in e}function v(e,r){const t=h(e,{name:r?.name,type:f.SIGNAL,equals:r?.equals}),c=Object.assign(()=>(E(t),t.value),{set:s=>{(t.equals??O)(t.value,s)||(t.value=s,t.version++,M(t))},update:s=>c.set(s(t.value)),peek:()=>t.value,[d]:t});return S(()=>y(t)),c}const i=new Set;function u(e){for(const[r]of e.sources)r.observers.delete(e);e.sources=new Map}function l(e){if(!e.compute)return!1;if(i.has(e)){let c="";for(const o of i)c+=`${o.name??`Node_${o.id}`}${o===e?" (cycle)":""} → `;c+=e.name??`Node_${e.id}`;const s=new Error(`⚠️ Cycle reference detected: ${c}`);return console.warn(s),e.error=s,e.dirty=!1,u(e),!1}i.add(e);const r=e.cleanup;u(e);const t=n.activeObserver;n.activeObserver=e;try{r?.(),e.cleanup=void 0;const c=e.compute(),s=!((e&&e.equals)??O)(e.value,c);return e.type===f.EFFECT?e.value=c:s&&(e.value=c,e.version++,M(e)),e.dirty=!1,e.error=void 0,s}catch(c){return e.error=c,e.dirty=!1,console.warn(`⚠️ Error in reactive computation${e.name?` (${e.name})`:""}:`,c),!1}finally{i.delete(e),n.activeObserver=t}}function $(e,r){const t=h(void 0,{name:r?.name,type:f.EFFECT,equals:r?.equals});t.compute=e,t.onDirty=()=>{t.onDirty=void 0,n.batchDepth>0?n.pendingEffects.add(t):(n.pendingEffects.add(t),b())},l(t);const c=()=>{t.cleanup&&(t.cleanup(),t.cleanup=void 0),u(t),n.pendingEffects.delete(t),t.compute=void 0};return S(()=>c()),c}function k(e){return!e.compute||!e.dirty?!1:l(e)}function C(e,r){const t=h(void 0,{name:r?.name,type:f.MEMO,equals:r?.equals});t.compute=e;const c=Object.assign(()=>(E(t),k(t),t.value),{peek:()=>t.value,[d]:t});return l(t),S(()=>y(t)),c}function A(e){n.batchDepth++;try{return e()}finally{n.batchDepth--,n.batchDepth===0&&n.pendingEffects.size>0&&b()}}function g(e,r,t){const c=n,s=c.contexts.get(e),o=c.contexts.has(e);c.contexts.set(e,r);try{return t()}catch(a){throw console.error(a),a}finally{o?c.contexts.set(e,s):c.contexts.delete(e)}}function F(e,r){const t=Symbol(r?.name??"context");return{id:t,defaultValue:e,Provider:(s,o)=>{const a=p(s)?s:v(s);return g(t,a,o)},DeferredProvider:s=>o=>{const a=p(s)?s:v(s);return g(t,a,o)}}}function q(e){const r=e.id,t=e.defaultValue;let c=n;for(;c;){if(c.contexts.has(r))return c.contexts.get(r);c=c.prevScope}return p(t)?t:v(t)}function T(e,r){const t=q(e);return C(()=>r(t()))}export{A as batchSignals,F as createContext,$ as createEffect,C as createMemo,I as createScope,v as createSignal,x as disposeScope,q as getContext,T as getContextSelector,N as getScopeId,S as onScopeCleanup,P as untrack};
