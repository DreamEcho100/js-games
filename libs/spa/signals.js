const o={SIGNAL:0,EFFECT:1,MEMO:2},S=Symbol("signal");let b=0,r={id:b++,depth:0,nextSignalId:0,batchDepth:0,activeObserver:null,pendingEffects:new Set,pendingMicrotask:!1,nextScopes:[],prevScope:null,nodes:new Set,cleanups:[],name:void 0};function g(e){for(const n of e.nextScopes)g(n);e.nextScopes=[];for(const n of e.nodes)d(n);e.nodes.clear(),e.pendingEffects.clear(),e.pendingMicrotask=!1,e.cleanups.forEach(n=>n()),e.cleanups=[],e.prevScope&&(e.prevScope.nextScopes=e.prevScope.nextScopes.filter(n=>n.id!==e.id)),e.prevScope=null}function w(e,n){const t=r,c={id:b++,name:n?.name,depth:t.depth+1,nextSignalId:0,batchDepth:0,activeObserver:null,pendingEffects:new Set,nodes:new Set,pendingMicrotask:!1,nextScopes:[],prevScope:n?.detached?null:t,cleanups:[]};n?.detached||t.nextScopes.push(c),r=c;let s;try{s=e()}finally{r=t}return{result:s,dispose:()=>{g(c)}}}function l(e){if(r?.cleanups)r.cleanups.push(e);else throw console.warn("⚠️ Attempted to register a cleanup function outside of a scope."),new Error("No active scope for cleanup registration.")}function M(){return r.id}function p(e,n){const t={id:r.nextSignalId++,version:0,value:e,compute:void 0,cleanup:void 0,error:void 0,dirty:!1,onDirty:void 0,sources:new Map,observers:new Set,scopeRef:r,...n};return r.nodes.add(t),t}function k(e){const n=r.activeObserver;r.activeObserver=null;try{return e()}finally{r.activeObserver=n}}function h(e){r.activeObserver&&(r.activeObserver.sources.has(e)||(r.activeObserver.sources.set(e,e.version),e.observers.add(r.activeObserver)))}function y(e){for(const n of e.pendingEffects)u(n);e.pendingEffects.clear();for(const n of e.nextScopes)y(n)}function v(){r.pendingMicrotask||r.pendingEffects.size===0||(r.pendingMicrotask=!0,queueMicrotask(()=>{r.pendingMicrotask=!1,y(r)}))}function m(e){const n=Array.from(e.observers);for(const t of n)t.dirty||(t.dirty=!0,t.onDirty?t.onDirty():(r.pendingEffects.add(t),r.batchDepth===0&&v()))}function d(e){e.cleanup&&(e.cleanup(),e.cleanup=void 0),i(e),e.scopeRef.pendingEffects.delete(e),e.scopeRef.nodes.delete(e),e.compute=void 0}const E=Object.is;function x(e,n){const t=p(e,{name:n?.name,type:o.SIGNAL,equals:n?.equals}),c=Object.assign(()=>(h(t),t.value),{set:s=>{(t.equals??E)(t.value,s)||(t.value=s,t.version++,m(t))},update:s=>c.set(s(t.value)),peek:()=>t.value,[S]:t});return l(()=>d(t)),c}const a=new Set;function i(e){for(const[n]of e.sources)n.observers.delete(e);e.sources=new Map}function u(e){if(!e.compute)return!1;if(a.has(e)){let c="";for(const f of a)c+=`${f.name??`Node_${f.id}`}${f===e?" (cycle)":""} → `;c+=e.name??`Node_${e.id}`;const s=new Error(`⚠️ Cycle reference detected: ${c}`);return console.warn(s),e.error=s,e.dirty=!1,i(e),!1}a.add(e);const n=e.cleanup;i(e);const t=r.activeObserver;r.activeObserver=e;try{n?.(),e.cleanup=void 0;const c=e.compute(),s=!((e&&e.equals)??E)(e.value,c);return e.type===o.EFFECT?e.value=c:s&&(e.value=c,e.version++,m(e)),e.dirty=!1,e.error=void 0,s}catch(c){return e.error=c,e.dirty=!1,console.warn(`⚠️ Error in reactive computation${e.name?` (${e.name})`:""}:`,c),!1}finally{a.delete(e),r.activeObserver=t}}function D(e,n){const t=p(void 0,{name:n?.name,type:o.EFFECT,equals:n?.equals});t.compute=e,t.onDirty=()=>{t.onDirty=void 0,r.batchDepth>0?r.pendingEffects.add(t):(r.pendingEffects.add(t),v())},u(t);const c=()=>{t.cleanup&&(t.cleanup(),t.cleanup=void 0),i(t),r.pendingEffects.delete(t),t.compute=void 0};return l(()=>c()),c}function O(e){return!e.compute||!e.dirty?!1:u(e)}function q(e,n){const t=p(void 0,{name:n?.name,type:o.MEMO,equals:n?.equals});t.compute=e;const c=Object.assign(()=>(h(t),O(t),t.value),{peek:()=>t.value,[S]:t});return u(t),l(()=>d(t)),c}function I(e){r.batchDepth++;try{return e()}finally{r.batchDepth--,r.batchDepth===0&&r.pendingEffects.size>0&&v()}}export{I as batchSignals,D as createEffect,q as createMemo,w as createScope,x as createSignal,g as disposeScope,M as getScopeId,l as onScopeCleanup,k as untrack};
