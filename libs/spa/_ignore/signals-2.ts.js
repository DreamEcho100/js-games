let m=1,c=null;const a=[];let b=!0;const w=100;let v=[];class D{root=null;nodeMap=new Map;levels=new Map;constructor(){this.root={id:0,version:0,sources:new Map,observers:new Set,name:"virtual-root",level:0,children:new Set},this.nodeMap.set(0,this.root),this.levels.set(0,new Set([this.root]))}addNode(e){this.nodeMap.has(e.id)||(this.nodeMap.set(e.id,e),e.children||(e.children=new Set),this.updateNodeLevel(e),this.levels.has(e.level)||this.levels.set(e.level,new Set),this.levels.get(e.level).add(e))}updateNodeLevel(e){let r=0;for(const[n]of e.sources)n.level!==void 0&&(r=Math.max(r,n.level));const s=r+1;e.level!==void 0&&e.level!==s&&(this.levels.get(e.level)?.delete(e),e.parent&&(e.parent.children?.delete(e),e.parent=void 0)),e.level=s,this.levels.has(s)||this.levels.set(s,new Set),this.levels.get(s).add(e);let i=null,o=-1;for(const[n]of e.sources)n.level!==void 0&&n.level>o&&(i=n,o=n.level);if(i?(e.parent=i,i.children||(i.children=new Set),i.children.add(e)):(e.parent=this.root,this.root.children.add(e)),e.children)for(const n of e.children)this.updateNodeLevel(n)}removeNode(e){if(this.nodeMap.has(e.id)){if(e.level!==void 0&&this.levels.get(e.level)?.delete(e),e.parent&&e.parent.children?.delete(e),e.children){for(const r of e.children)this.updateNodeLevel(r);e.children.clear()}this.nodeMap.delete(e.id)}}getAllNodes(){return Array.from(this.nodeMap.values()).filter(e=>e!==this.root)}getNodesAtLevel(e){return Array.from(this.levels.get(e)||[])}getMaxLevel(){return Math.max(...this.levels.keys())}getNodesInTopologicalOrder(){const e=[],r=this.getMaxLevel();for(let s=0;s<=r;s++){const i=this.getNodesAtLevel(s);for(const o of i)o!==this.root&&e.push(o)}return e}getAncestors(e){const r=[];let s=e.parent;for(;s&&s!==this.root;)r.push(s),s=s.parent;return r}getDescendants(e){const r=[],s=i=>{if(i.children)for(const o of i.children)r.push(o),s(o)};return s(e),r}}const l=new D;function E(t,e={}){const r={id:m++,version:0,value:t,sources:new Map,observers:new Set,name:e.name,children:new Set,level:1};l.addNode(r);function s(){if(c){const o=!c.sources.has(r);c.sources.set(r,r.version),r.observers.add(c),o&&l.updateNodeLevel(c)}return r.value}function i(o){(e.equals??Object.is)(r.value,o)||(r.value=o,r.version++,k(r))}return y(()=>{l.removeNode(r),r.sources.clear(),r.observers.clear(),r.cleanup?.()}),Object.assign(s,{set:i,update(o){i(o(r.value))},peek(){return r.value}})}function k(t){for(const e of t.observers)M(e);S()}let d=0;const f=new Set;let p=!1;function O(t){d++;try{t()}finally{d--,d===0&&N()}}function M(t){t.dirty||(t.dirty=!0,t.onDirty?.(),t.compute&&f.add(t))}function N(){for(p=!1,T();v.length>0;){const t=v.shift();if(f.delete(t),t.disposed)continue;if(L(t)){console.warn(`Skipping computation of node ${t.name||t.id} due to circular dependency`);continue}g(t)}}function S(){d>0||p||(p=!0,queueMicrotask(N))}function C(t,e){const r={id:m++,version:0,sources:new Map,observers:new Set,compute:t,cleanup:void 0,name:e,dirty:!0,children:new Set,onDirty(){f.add(r)}};return l.addNode(r),y(()=>{l.removeNode(r),h(r)}),g(r),()=>{l.removeNode(r),h(r)}}function g(t){if(!t.disposed){t.cleanup?.();for(const[e]of t.sources)e.observers.delete(t);if(t.sources.clear(),t.dirty=!1,a.length>w){console.error(`Maximum computation depth exceeded (${w}). Possible infinite loop.`);return}a.push(t),c=t;try{const e=t.compute();t.cleanup=typeof e=="function"?e:void 0,t.value=e}catch(e){t.error=e,console.error(`Error in computation ${t.name||t.id}:`,e)}finally{a.pop(),c=a[a.length-1]||null}}}function h(t){if(!t.disposed){t.cleanup?.();for(const[e]of t.sources)e.observers.delete(t);for(const e of t.observers)e.sources.delete(t);t.sources.clear(),t.observers.clear(),t.compute=void 0,t.cleanup=void 0,t.value=void 0,t.onDirty=void 0,t.disposed=!0}}function R(t,e){const r={id:m++,version:0,sources:new Map,observers:new Set,compute:t,value:void 0,dirty:!0,name:e,children:new Set,onDirty(){M(r),S()}};l.addNode(r),y(()=>{l.removeNode(r),h(r)});function s(){if(c){const i=!c.sources.has(r);c.sources.set(r,r.version),r.observers.add(c),i&&l.updateNodeLevel(c)}return r.dirty&&(g(r),r.version++),r.value}return s}function q(){const t=[];return{run(e){const r=t.length;return e(),()=>{for(;t.length>r;)t.pop()()}},track(e){t.push(e)}}}let u=null;function y(t){u&&u.disposers.add(t)}function z(t){const e={disposers:new Set},r=u;u=e;const s=()=>{for(const i of e.disposers)i();e.disposers.clear()};try{return t(s)}finally{u=r}}function L(t,e=new Set){if(!b)return!1;if(e.has(t.id))return console.error(`Cycle detected in reactive graph involving node ${t.name||t.id}`),!0;e.add(t.id);for(const[r]of t.sources)if(L(r,e))return!0;return e.delete(t.id),!1}function T(){v=l.getNodesInTopologicalOrder().filter(t=>f.has(t))}function I(t){b=t}function $(){const t=[],e=l.getMaxLevel();for(let r=0;r<=e;r++){const s=l.getNodesAtLevel(r);if(s.length===0)continue;const i="  ".repeat(r),o=`${i}Level ${r}:`;t.push(o);for(const n of s){if(n.id===0)continue;const A=n.name||`Node ${n.id}`,x=n.compute&&n.observers.size>0?"Memo":n.compute?"Effect":"Signal";t.push(`${i}  ${A} (${x})`)}}return t.join(`
`)}function P(){const t={},e=l.getAllNodes();for(const r of e)t[r.id]={id:r.id,name:r.name,type:r.compute&&r.observers.size>0?"Memo":r.compute?"Effect":"Signal",level:r.level||0,dependencies:Array.from(r.sources.keys()).map(s=>s.id),observers:Array.from(r.observers).map(s=>s.id),children:Array.from(r.children||[]).map(s=>s.id),parent:r.parent?.id};return{nodes:t,tree:$()}}export{O as createBatch,C as createEffect,R as createMemo,z as createRoot,q as createScope,E as createSignal,P as getReactiveGraphDebug,$ as getReactiveTreeVisualization,I as setCycleDetection};
