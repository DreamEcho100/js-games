const w=Symbol("signal"),$=Symbol("UNSET"),q=Symbol("COMPUTING"),G=Symbol("ERRORED");let N=0,I=null;const g=new Set;let v=!1,A=!1;const b={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!0,consumerIsAlwaysLive:!1,producerMustRecompute(){return!1},producerRecomputeValue(){},consumerMarkedDirty(){},consumerOnSignalRead(e){B(this,e)}};function V(e,t){return Object.is(e,t)}const k=new Map;let H=1;function O(e){const t=H++;return e.nodeId=t,k.set(t,e),t}function z(e){e.nodeId&&(k.delete(e.nodeId),e.nodeId=void 0)}function oe(e){return k.get(e)}function B(e,t){const n=e.nextProducerIndex++;if(e.producerNode||(e.producerNode=[],e.producerLastReadVersion=[],e.producerIndexOfThis=[]),n<e.producerNode.length&&e.producerNode[n]!==t&&W(e)&&e.producerIndexOfThis){const r=e.producerNode[n];j(r,e.producerIndexOfThis[n])}e.producerNode[n]!==t&&e.producerIndexOfThis&&(e.producerNode[n]=t,e.producerIndexOfThis[n]=W(e)?Q(t,e,n):0),e.producerLastReadVersion&&(e.producerLastReadVersion[n]=t.version)}function S(e){const t=I;return I=e,t}function Z(){return I===null||I.consumerAllowSignalWrites}function D(e){if(A)throw new L("Signal read during notification phase");I!==null&&B(I,e)}function Q(e,t,n){e.liveConsumerNode||(e.liveConsumerNode=[],e.liveConsumerIndexOfThis=[],e.watched?.());const r=e.liveConsumerNode.length;return e.liveConsumerNode.push(t),e.liveConsumerIndexOfThis&&e.liveConsumerIndexOfThis.push(n),r}function j(e,t){if(!e.liveConsumerNode||!e.liveConsumerIndexOfThis)return;const n=e.liveConsumerNode.length-1;if(t!==n){const r=e.liveConsumerNode[n],o=e.liveConsumerIndexOfThis[n];e.liveConsumerNode[t]=r,e.liveConsumerIndexOfThis[t]=o,r.producerIndexOfThis&&(r.producerIndexOfThis[o]=t)}e.liveConsumerNode.pop(),e.liveConsumerIndexOfThis.pop(),e.liveConsumerNode.length===0&&e.unwatched?.()}function W(e){return e.consumerIsAlwaysLive||e.liveConsumerNode!==void 0&&e.liveConsumerNode.length>0}function X(e){!e.dirty&&e.lastCleanEpoch===N||((e.dirty||e.producerMustRecompute(e))&&(e.producerRecomputeValue(e),e.dirty=!1),e.lastCleanEpoch=N)}function Y(e){e.dirty||(e.dirty=!0,e.consumerMarkedDirty.call(e))}function J(e){const t=e.liveConsumerNode;if(!t||t.length===0)return;const n=A;A=!0;try{for(const r of t)Y(r)}finally{A=n}}function C(e){const t=Object.create(b);t.value=e,t.equal=V,t.version=0,O(t);const n=()=>(D(t),t.value);return n.set=r=>{if(!Z())throw new L("Cannot set signal value during effect execution");t.equal(t.value,r)||(t.value=r,t.version++,N++,J(t),v||T())},n.update=r=>{n.set(r(t.value))},n[w]=t,n}function M(e){const t=Object.create(b);t.value=$,t.error=null,t.equal=V,t.computation=e,t.dirty=!0,t.version=0,O(t),t.producerMustRecompute=r=>{const o=r;return o.value===$||o.value===q},t.producerRecomputeValue=r=>{const o=r;if(o.value===q)throw new L("Detected cycle in computations");const i=o.value;o.value=q;const s=S(o);let u,a=!1;try{o.nextProducerIndex=0,u=o.computation(),a=i!==$&&i!==G&&o.equal(i,u)}catch(c){u=G,o.error=c}finally{S(s),P(o)}if(a){o.value=i;return}o.value=u,o.version++};const n=()=>{if(X(t),D(t),t.value===G)throw t.error;return t.value};return n[w]=t,n}function x(e){let t;const n=o=>{t=o},r=Object.create(b);return r.consumerIsAlwaysLive=!0,r.dirty=!0,r.consumerAllowSignalWrites=!1,O(r),r.execute=()=>{if(t){try{t()}catch(i){console.error("Error in effect cleanup:",i)}t=void 0}r.nextProducerIndex=0;const o=S(r);try{e(n)}finally{S(o),P(r),r.dirty=!1}},r.consumerMarkedDirty=()=>{r.dirty||(r.dirty=!0,g.add(r),v||T())},r.execute(),()=>{g.delete(r);const{producerNode:o,producerIndexOfThis:i}=r;if(o&&i)for(let s=0;s<o.length;s++)j(o[s],i[s]);t&&(t(),t=void 0),z(r)}}function ie(e){const t=v;v=!0;try{e()}finally{v=t,v||T()}}function T(){if(g.size===0)return;const e=Array.from(g);g.clear(),e.sort((t,n)=>{const r=t,o=n,i=r.priority??1,s=o.priority??1;return i!==s?i-s:t.version-n.version});for(const t of e)if(t.dirty){const n=t;typeof n.execute=="function"?n.execute():t.execute()}}function P(e){const{producerNode:t,producerIndexOfThis:n,nextProducerIndex:r}=e;if(!(!t||!n)&&r<t.length){for(let o=r;o<t.length;o++)W(e)&&j(t[o],n[o]);t.length=r,n.length=r,e.producerLastReadVersion&&(e.producerLastReadVersion.length=r)}}let E={debugMode:!1,logger:console.log,maxIterations:100,trackOrigins:!1};function ee(e){E={...E,...e}}class L extends Error{constructor(t,n){super(t),this.details=n,this.name="ReactiveError",Error.captureStackTrace&&Error.captureStackTrace(this,L)}}function F(e,...t){E.debugMode&&E.logger(`[Reactive] ${e}`,...t)}var te=(e=>(e[e.HIGH=0]="HIGH",e[e.NORMAL=1]="NORMAL",e[e.LOW=2]="LOW",e))(te||{});function se(e,t={}){let n,r=0,o;const i=u=>{n=u},s=Object.create(b);return s.consumerIsAlwaysLive=!0,s.dirty=!0,s.consumerAllowSignalWrites=!1,s.priority=t.priority??1,O(s),t.throttle&&(s.throttleMs=t.throttle),E.trackOrigins&&(s.trackingInfo={createdAt:new Date,type:"effect",name:t.name,stackTrace:new Error().stack}),s.execute=()=>{const u=Date.now();if(s.throttleMs&&u-r<s.throttleMs){o||(o=setTimeout(()=>{o=void 0,s.dirty&&s.execute()},s.throttleMs-(u-r)));return}if(r=u,n){try{n()}catch(c){console.error("Error in effect cleanup:",c)}n=void 0}s.nextProducerIndex=0;const a=S(s);try{F(`Running effect${t.name?` "${t.name}"`:""}`),e(i)}catch(c){console.error(`Error in effect${t.name?` "${t.name}"`:""}:`,c)}finally{S(a),P(s),s.dirty=!1}},s.consumerMarkedDirty=()=>{s.dirty||(s.dirty=!0,g.add(s),v||(!s.throttleMs||!o)&&T())},s.execute(),()=>{g.delete(s),o&&(clearTimeout(o),o=void 0);const{producerNode:u,producerIndexOfThis:a}=s;if(u&&a)for(let c=0;c<u.length;c++)j(u[c],a[c]);n&&(n(),n=void 0),z(s)}}function ce(e,t={}){const n=Object.create(b);n.value=e,n.equal=t.equals||V,n.version=0,O(n),E.trackOrigins&&(n.trackingInfo={createdAt:new Date,type:"signal",name:t.name,stackTrace:new Error().stack});const r=()=>(F(`Reading signal${t.name?` "${t.name}"`:""}: ${String(n.value)}`),D(n),n.value);return r.set=o=>{if(!Z())throw new L("Cannot set signal value during effect execution");F(`Setting signal${t.name?` "${t.name}"`:""}: ${String(n.value)} â†’ ${String(o)}`),n.equal(n.value,o)||(n.value=o,n.version++,N++,J(n),v||T())},r.update=o=>{r.set(o(n.value))},r[w]=n,r}function ne(e,t,n){if(e instanceof HTMLInputElement&&t==="value"){const r=x(i=>{const s=n();e.value=String(s);const u=n;if(typeof u.set=="function"){const a=()=>{u.set(e.value)};e.addEventListener("input",a),i(()=>e.removeEventListener("input",a))}}),o=new MutationObserver(i=>{for(const s of i)if(s.type==="childList"&&!document.contains(e)){r(),o.disconnect();break}});return o.observe(document.body,{childList:!0,subtree:!0}),()=>{r(),o.disconnect()}}return x(t==="class"||t==="className"?()=>{const r=n();if(typeof r=="object"&&r!==null)for(const[o,i]of Object.entries(r))i?e.classList.add(o):e.classList.remove(o);else e.className=String(r)}:t==="style"?()=>{const r=n();typeof r=="object"&&r!==null?Object.assign(e.style,r):e.style.cssText=String(r)}:()=>{const r=n();t in e?e[t]=r:r===!1||r===null||r===void 0?e.removeAttribute(t):e.setAttribute(t,String(r===!0?"":r))})}function ue(e,t,...n){const r=document.createElement(e);if(t)for(const[o,i]of Object.entries(t)){if(o.startsWith("on")&&typeof i=="function"){const s=o.slice(2).toLowerCase();r.addEventListener(s,i);continue}if(_(i)){ne(r,o,i);continue}o in r?r[o]=i:i===!1||i===null||i===void 0?r.removeAttribute(o):r.setAttribute(o,String(i===!0?"":i))}for(const o of n)if(typeof o=="string")r.appendChild(document.createTextNode(o));else if(_(o)){const i=document.createTextNode("");r.appendChild(i),x(()=>{i.textContent=String(o())})}else o instanceof Node&&r.appendChild(o);return r}function _(e){return typeof e=="function"&&w in e}function ae(e,t,n){return e.addEventListener(t,n),()=>e.removeEventListener(t,n)}function le(e){const t=C(e),n=t[w];return{signal:t,setValue:r=>t.set(r),getValue:()=>n.value,getVersion:()=>n.version,getConsumers:()=>n.liveConsumerNode?[...n.liveConsumerNode]:[],dispose:()=>z(n)}}function fe(){T()}function de(){N=0,I=null,g.clear(),v=!1,A=!1,k.clear(),H=1}function re(){const e=[],t=[];for(const[n,r]of k.entries()){const o=r;"value"in o?e.push({id:n,value:o.value,version:r.version,consumers:r.liveConsumerNode?.map(i=>i.nodeId??-1).filter(i=>i!==-1)||[],info:o.trackingInfo}):"execute"in o&&t.push({id:n,dirty:r.dirty,priority:r.priority,dependencies:r.producerNode?.map(i=>i.nodeId??-1).filter(i=>i!==-1)||[],info:o.trackingInfo})}return{signals:e,effects:t,epoch:N}}function ve(e={}){const t=e.target||window,n="__REACTIVE_DEVTOOLS__";t[n]||(t[n]={getSnapshot:re,configure:ee});const r=new CustomEvent("reactive-devtools-connected",{detail:{version:"1.0.0"}});return t.dispatchEvent(r),()=>{delete t[n]}}const U=new Map;function pe(e){const t={Provider:({value:n,children:r})=>{let o=U.get(t);o||(o=[],U.set(t,o)),o.push(n);try{r()}finally{o.pop()}},Consumer:({children:n})=>{const r=t.useContext();n(r)},useContext:()=>{const n=U.get(t);return!n||n.length===0?e:n[n.length-1]}};return t}function ge(e,t){return M(()=>e().map(t))}function he(e,t){return M(()=>e().filter(t))}function me(e,t,n){return M(()=>e().reduce(t,n))}function ye(e,t,n){return M(()=>e().slice(t,n))}function Ce(e,t,n={}){const r=C("unresolved"),o=C(null),i=C(n.initialValue),s=M(()=>r()==="pending");let u,a,c,p=0;const h=async(m,y)=>{try{c&&c.abort(),c=new AbortController,r.set("pending");const d=await Promise.race([t(m),new Promise((R,K)=>{c.signal.addEventListener("abort",()=>{K(new Error("Fetch aborted due to new source value"))})})]);return y!==p||(i.set(d),r.set("success"),o.set(null),n.onSuccess?.(d)),d}catch(d){if(y!==p)throw d;const R=d instanceof Error?d:new Error(String(d));throw R.name!=="AbortError"&&(r.set("error"),o.set(R),n.onError?.(R)),R}finally{y===p&&(c=void 0)}},f=()=>{if(a===void 0)throw new Error("Cannot refetch without a source value");p++;const y=h(a,p);return u=y,y};e&&x(()=>{const m=e();a=m,p++,u=h(m,p)});const l=()=>i();return l.status=r,l.loading=s,l.error=o,l.refetch=f,l}function Ie(e){const t=Symbol("uninitialized");let n=!1,r=t,o=null,i;const s=C(!1),u=C(void 0),a=C(null),c=Object.create(b);c.value=void 0,c.equal=V,c.version=0,O(c);const h=()=>{if(!n){n=!0;try{s.set(!0);const f=e();f instanceof Promise?(i&&i.abort(),i=new AbortController,f.then(l=>{i?.signal.aborted||(r=l,u.set(l),c.value=l,c.version++,s.set(!1))}).catch(l=>{i?.signal.aborted||(o=l instanceof Error?l:new Error(String(l)),a.set(o),s.set(!1))})):(r=f,u.set(f),c.value=f,c.version++,s.set(!1))}catch(f){o=f instanceof Error?f:new Error(String(f)),a.set(o),s.set(!1)}}return D(c),u()};return h.loading=s,h.error=a,h[w]=c,h}export{te as EffectPriority,L as ReactiveError,ie as batchSignals,ne as bind,ee as configureReactive,ve as connectDevTools,pe as createContext,x as createEffect,se as createEffectWithOptions,ue as createElement,Ie as createLazy,M as createMemo,le as createMockSignal,Ce as createResource,C as createSignal,ce as createSignalWithOptions,he as filterSignal,oe as findNodeById,fe as flushEffects,re as getReactiveSnapshot,_ as isSignal,ge as mapSignal,ae as on,me as reduceSignal,de as resetReactiveSystem,ye as sliceSignal};
