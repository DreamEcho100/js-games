let m=1,c=null;const u=[];let N=!0;const M=100;let v=[];class D{root=void 0;nodeMap=new Map;levels=new Map;constructor(){this.root={id:0,version:0,sources:new Map,observers:new Set,name:"virtual-root",level:0,children:new Set},this.nodeMap.set(0,this.root),this.levels.set(0,new Set([this.root]))}addNode(e){this.nodeMap.has(e.id)||(this.nodeMap.set(e.id,e),e.children||(e.children=new Set),this.updateNodeLevel(e),this.levels.has(e.level)||this.levels.set(e.level,new Set),this.levels.get(e.level).add(e))}updateNodeLevel(e){let r=0;for(const[n]of e.sources)n.level!==void 0&&(r=Math.max(r,n.level));const s=r+1;e.level!==void 0&&e.level!==s&&(this.levels.get(e.level)?.delete(e),e.parent&&(e.parent.children?.delete(e),e.parent=void 0)),e.level=s,this.levels.has(s)||this.levels.set(s,new Set),this.levels.get(s).add(e);let i=null,o=-1;for(const[n]of e.sources)n.level!==void 0&&n.level>o&&(i=n,o=n.level);if(i?(e.parent=i,i.children||(i.children=new Set),i.children.add(e)):(e.parent=this.root,this.root.children.add(e)),e.children)for(const n of e.children)this.updateNodeLevel(n)}removeNode(e){if(this.nodeMap.has(e.id)){if(e.level!==void 0&&this.levels.get(e.level)?.delete(e),e.parent&&e.parent.children?.delete(e),e.children){for(const r of e.children)this.updateNodeLevel(r);e.children.clear()}this.nodeMap.delete(e.id)}}getAllNodes(){return Array.from(this.nodeMap.values()).filter(e=>e!==this.root)}getNodesAtLevel(e){return Array.from(this.levels.get(e)||[])}getMaxLevel(){return Math.max(...this.levels.keys())}getNodesInTopologicalOrder(){const e=[],r=this.getMaxLevel();for(let s=0;s<=r;s++){const i=this.getNodesAtLevel(s);for(const o of i)o!==this.root&&e.push(o)}return e}getAncestors(e){const r=[];let s=e.parent;for(;s&&s!==this.root;)r.push(s),s=s.parent;return r}getDescendants(e){const r=[],s=i=>{if(i.children)for(const o of i.children)r.push(o),s(o)};return s(e),r}}const l=new D;function p(t,e){if(Object.is(t,e))return!0;if(t===null||e===null||typeof t!="object"||typeof e!="object")return!1;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!p(t[i],e[i]))return!1;return!0}if(t.constructor!==e.constructor)return!1;if(t instanceof Date)return t.getTime()===e.getTime();if(t instanceof RegExp)return t.toString()===e.toString();const r=Object.keys(t),s=Object.keys(e);if(r.length!==s.length)return!1;for(const i of r)if(!p(t[i],e[i]))return!1;return!0}function $(t,e={}){const r={id:m++,version:0,value:t,sources:new Map,observers:new Set,name:e.name,children:new Set,level:1};l.addNode(r);function s(){if(c){const o=!c.sources.has(r);c.sources.set(r,r.version),r.observers.add(c),o&&l.updateNodeLevel(c)}return r.value}function i(o){(e.equals??p)(r.value,o)||(r.value=o,r.version++,T(r))}return w(()=>{l.removeNode(r),r.sources.clear(),r.observers.clear(),r.cleanup?.()}),Object.assign(s,{set:i,update(o){i(o(r.value))},peek(){return r.value}})}function T(t){for(const e of t.observers)S(e);b()}let f=0;const d=new Set;let h=!1;function j(t){f++;try{t()}finally{f--,f===0&&L()}}function S(t){t.dirty||(t.dirty=!0,t.onDirty?.(),t.compute&&d.add(t))}function L(){for(h=!1,E();v.length>0;){const t=v.shift();if(d.delete(t),t.disposed)continue;if(A(t)){console.warn(`Skipping computation of node ${t.name||t.id} due to circular dependency`);continue}y(t)}}function b(){f>0||h||(h=!0,queueMicrotask(L))}function C(t,e){const r={id:m++,version:0,sources:new Map,observers:new Set,compute:t,cleanup:void 0,name:e,dirty:!0,children:new Set,onDirty(){d.add(r)}};return l.addNode(r),w(()=>{l.removeNode(r),g(r)}),y(r),()=>{l.removeNode(r),g(r)}}function y(t){if(!t.disposed){t.cleanup?.();for(const[e]of t.sources)e.observers.delete(t);if(t.sources.clear(),t.dirty=!1,u.length>M){console.error(`Maximum computation depth exceeded (${M}). Possible infinite loop.`);return}u.push(t),c=t;try{const e=t.compute();t.cleanup=typeof e=="function"?e:void 0,t.value=e}catch(e){t.error=e,console.error(`Error in computation ${t.name||t.id}:`,e)}finally{u.pop(),c=u[u.length-1]||null}}}function g(t){if(!t.disposed){t.cleanup?.();for(const[e]of t.sources)e.observers.delete(t);for(const e of t.observers)e.sources.delete(t);t.sources.clear(),t.observers.clear(),t.compute=void 0,t.cleanup=void 0,t.value=void 0,t.onDirty=void 0,t.disposed=!0}}function R(t,e){const r={id:m++,version:0,sources:new Map,observers:new Set,compute:t,value:void 0,dirty:!0,name:e,children:new Set,onDirty(){S(r),b()}};l.addNode(r),w(()=>{l.removeNode(r),g(r)});function s(){if(c){const i=!c.sources.has(r);c.sources.set(r,r.version),r.observers.add(c),i&&l.updateNodeLevel(c)}return r.dirty&&(y(r),r.version++),r.value}return s}function q(){const t=[];return{run(e){const r=t.length;return e(),()=>{for(;t.length>r;)t.pop()()}},track(e){t.push(e)}}}let a=null;function w(t){a&&a.disposers.add(t)}function z(t){const e={disposers:new Set},r=a;a=e;const s=()=>{for(const i of e.disposers)i();e.disposers.clear()};try{return t(s)}finally{a=r}}function A(t,e=new Set){if(!N)return!1;if(e.has(t.id))return console.error(`Cycle detected in reactive graph involving node ${t.name||t.id}`),!0;e.add(t.id);for(const[r]of t.sources)if(A(r,e))return!0;return e.delete(t.id),!1}function E(){v=l.getNodesInTopologicalOrder().filter(t=>d.has(t))}function I(t){N=t}function O(){const t=[],e=l.getMaxLevel();for(let r=0;r<=e;r++){const s=l.getNodesAtLevel(r);if(s.length===0)continue;const i="  ".repeat(r),o=`${i}Level ${r}:`;t.push(o);for(const n of s){if(n.id===0)continue;const k=n.name||`Node ${n.id}`,x=n.compute&&n.observers.size>0?"Memo":n.compute?"Effect":"Signal";t.push(`${i}  ${k} (${x})`)}}return t.join(`
`)}function P(){const t={},e=l.getAllNodes();for(const r of e)t[r.id]={id:r.id,name:r.name,type:r.compute&&r.observers.size>0?"Memo":r.compute?"Effect":"Signal",level:r.level||0,dependencies:Array.from(r.sources.keys()).map(s=>s.id),observers:Array.from(r.observers).map(s=>s.id),children:Array.from(r.children||[]).map(s=>s.id),parent:r.parent?.id};return{nodes:t,tree:O()}}export{j as createBatch,C as createEffect,R as createMemo,z as createRoot,q as createScope,$ as createSignal,P as getReactiveGraphDebug,O as getReactiveTreeVisualization,I as setCycleDetection};
